//##############################################################################// Mines - CMinesApp.cp				by Matt Gallagher ©1999 All rights reserved//##############################################################################// PowerPlant Classes included for registration#include <UControlRegistry.h>#include <LActiveScroller.h>#include <LBevelButton.h>#include <LAMBevelButtonImp.h>#include <LGABevelButtonImp.h>// Macintosh header file for the call to RegisterAppearanceClient#include <Appearance.h>// Application headers#include "CMinesApp.h"#include "CMinesConstants.h"#include "CMinesView.h"#include "CMinesWindow.h"//#############################// Program main()//#############################void main( void ){	// Initialize the heap. Parameter is number of master handle	// blocks to allocate.	InitializeHeap( 4 );		// Initialize the MacOS toolbox.	UQDGlobals::InitializeToolbox( &qd );	::GetDateTime( (unsigned long *)&qd.randSeed );	// Install a GrowZone function to catch  low memory situations.	// Parameter is the size of the memory reserve in bytes.	new LGrowZone( 20000 );	// Create the application object and run it.	CMinesApp	theApp;	theApp.Run();}//#############################// CMinesApp - Class Registration and initialising//#############################CMinesApp::CMinesApp(){	// Setup the throw and signal actions.	SetDebugThrow_( debugAction_Alert );	SetDebugSignal_( debugAction_Alert );	// Register appearance manager classes	if (UEnvironment::HasFeature (env_HasAppearance)) {		::RegisterAppearanceClient();		UControlRegistry::RegisterAMClasses();				// Note: Registering GABevelButton, cause AM is fucked		URegistrar::UnregisterClass(LBevelButton::imp_class_ID);		RegisterClassID_(LGABevelButtonImp, LBevelButton::imp_class_ID);	}	else	{		UControlRegistry::RegisterGAClasses();	}		// Register other required PowerPlant core classes.	RegisterClass_(LDialogBox);	RegisterClass_(LActiveScroller);	RegisterClass_(LStdButton);	RegisterClass_(LPicture);	RegisterClass_(LView);	RegisterClass_(LPlaceHolder);	RegisterClass_(LWindow);	// Register custom classes.	RegisterClass_(CMinesView);	RegisterClass_(CMinesWindow);	RegisterClass_(COptionsWindow);		// Create the options windows	mOptionsWindow	= static_cast<COptionsWindow *>					  (LWindow::CreateWindow( rPPob_OptionsWindow, this ));	ThrowIfNil_( mOptionsWindow );			// Get the text for the options window menu item	mShowText.Assign( textListR, 1 );	mHideText.Assign( textListR, 2 );}//#############################// CMinesApp - Destructor//#############################CMinesApp::~CMinesApp(){}//#############################// CMinesApp - Startup without document//#############################void CMinesApp::StartUp(){	// Create the single application window.	ObeyCommand( cmd_New, nil );}//#############################// CMinesApp - Create the game window//#############################LModelObject* CMinesApp::MakeNewDocument(){	// Create the window.	CMinesWindow	*minesWindow;	minesWindow		= static_cast<CMinesWindow *>(LWindow::CreateWindow(						rPPob_MinesWindow, mOptionsWindow ));	ThrowIfNil_( minesWindow );		// Show the window.	minesWindow->Show();		return minesWindow;}//#############################// CMinesApp - ObeyCommands//#############################Boolean CMinesApp::ObeyCommand( CommandT inCommand, void *ioParam ){	Boolean cmdHandled=true;	switch( inCommand )	{		case cmd_Options:		{			if( mOptionsWindow->IsVisible() )			{				mOptionsWindow->Hide();			}			else			{				mOptionsWindow->Show();			}		}		break;		default:		{			// Call inherited.			cmdHandled = LDocApplication::ObeyCommand( inCommand, ioParam );		}		break;	}		return cmdHandled;}//#############################// Update Menus//#############################void CMinesApp::FindCommandStatus( CommandT inCommand, Boolean &outEnabled,	Boolean &outUsesMark, Char16 &outMark, Str255 outName ){	switch( inCommand )	{		case cmd_New:		{			// You can always start a new game			outEnabled = true;		}		break;		case cmd_Options:		{			// Show can only view the options window if a window is visible			LWindow *topWindow = UDesktop::FetchTopRegular();			if( topWindow != nil &&				topWindow->GetPaneID()==rPPob_MinesWindow )			{				outEnabled = true;				if( mOptionsWindow->IsVisible() )				{					// Make the text read "Hide Game Options"					CopyPStr(mHideText, outName, sizeof(Str255));				}				else				{					// Make the menu item text read "Show Game Options"					CopyPStr(mShowText, outName, sizeof(Str255));				}			}			else			{				// Of course, if there are no windows open, disable the menu				mOptionsWindow->Hide();				outEnabled = false;			}		}		break;				default:		{			// Call inherited.			LDocApplication::FindCommandStatus( inCommand, outEnabled,				outUsesMark, outMark, outName );		}		break;	}}//#############################// Open a new window document//#############################void CMinesApp::OpenDocument( FSSpec *inMacFSSpec ){#pragma unused (inMacFSSpec)	// Create a new document	MakeNewDocument();		// Open the file and get the mines data out of it		// Send the data in a command to the target (which is the new window)}//#############################// Choose a new document using the standard get file//#############################voidCMinesApp::ChooseDocument(){	// Deactivate the desktop.	::UDesktop::Deactivate();	// Browse for a document.	SFTypeList			theTypeList = {'Myns'};	StandardFileReply	theReply;	::StandardGetFile( nil, 1, theTypeList, &theReply );	// Activate the desktop.	::UDesktop::Activate();		// Send an apple event to open the file.		if ( theReply.sfGood ) SendAEOpenDoc( theReply.sfFile );}